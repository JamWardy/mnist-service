<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Drawable MNIST Classifier</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 600px;
      margin: 40px auto;
      text-align: center;
    }
    #canvas-container {
      margin: 20px auto;
    }
    #draw-canvas {
      border: 1px solid #ddd;
      touch-action: none;
    }
    button {
      margin: 8px;
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
    }
    .result {
      margin-top: 20px;
      font-size: 1.5rem;
      font-weight: bold;
    }
    .error {
      color: #b00020;
      margin-top: 10px;
    }
    .hint {
      margin-top: 10px;
      font-size: 0.9rem;
      color: #555;
    }
  </style>
</head>
<body>
  <h1>Draw a Digit, and the model will classify it!</h1>

  <div id="canvas-container">
    <canvas id="draw-canvas" width="280" height="280"></canvas>
  </div>

  <div>
    <button id="clear-btn" type="button">Clear</button>
    <button id="predict-btn" type="button">Classify</button>
  </div>

  <div class="result" id="result"></div>
  <div class="error" id="error"></div>

  <script>
    const canvas = document.getElementById('draw-canvas');
    const ctx = canvas.getContext('2d');
    const clearBtn = document.getElementById('clear-btn');
    const predictBtn = document.getElementById('predict-btn');
    const resultDiv = document.getElementById('result');
    const errorDiv = document.getElementById('error');

    const CANVAS_SIZE = 280;
    const MNIST_SIZE = 28;

    function initCanvas() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 20;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
    }

    initCanvas();

    let drawing = false;

    function getCanvasPos(event) {
      const rect = canvas.getBoundingClientRect();
      if (event.touches && event.touches[0]) {
        return {
          x: event.touches[0].clientX - rect.left,
          y: event.touches[0].clientY - rect.top
        };
      } else {
        return {
          x: event.clientX - rect.left,
          y: event.clientY - rect.top
        };
      }
    }

    function startDrawing(event) {
      drawing = true;
      const pos = getCanvasPos(event);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      event.preventDefault();
    }

    function draw(event) {
      if (!drawing) return;
      const pos = getCanvasPos(event);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      event.preventDefault();
    }

    function stopDrawing(event) {
      if (!drawing) return;
      drawing = false;
      event.preventDefault();
    }

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);

    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);
    canvas.addEventListener('touchcancel', stopDrawing);

    clearBtn.addEventListener('click', () => {
      initCanvas();
      resultDiv.textContent = '';
      errorDiv.textContent = '';
    });

    async function sendDrawing() {
      resultDiv.textContent = '';
      errorDiv.textContent = '';

      const smallCanvas = document.createElement('canvas');
      smallCanvas.width = MNIST_SIZE;
      smallCanvas.height = MNIST_SIZE;
      const sctx = smallCanvas.getContext('2d');

      sctx.drawImage(canvas, 0, 0, MNIST_SIZE, MNIST_SIZE);

      smallCanvas.toBlob(async (blob) => {
        if (!blob) {
          errorDiv.textContent = 'Failed to create image blob.';
          return;
        }

        const formData = new FormData();
        formData.append('file', blob, 'digit.png');

        try {
          const response = await fetch('/predict', {
            method: 'POST',
            body: formData
          });

          const data = await response.json();

          if (!response.ok || data.error) {
            throw new Error(data.error || 'Server error');
          }

          resultDiv.textContent = `Prediction: ${data.digit} \n Confidence: ${data.confidence}`;
        } catch (err) {
          errorDiv.textContent = 'Error: ' + err.message;
        }
      }, 'image/png');
    }

    predictBtn.addEventListener('click', sendDrawing);
  </script>
</body>
</html>
